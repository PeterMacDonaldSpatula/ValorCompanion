package petermacdonald.valorgmcompanion.character.techniques;

import java.util.ArrayList;
import java.util.List;

import petermacdonald.valorgmcompanion.character.ValorCharacter;
import petermacdonald.valorgmcompanion.character.enums.CoreAttribute;
import petermacdonald.valorgmcompanion.character.techniques.limits.Limit;
import petermacdonald.valorgmcompanion.character.techniques.mods.Line;
import petermacdonald.valorgmcompanion.character.techniques.mods.Mod;
import petermacdonald.valorgmcompanion.character.techniques.mods.Ranged;
import petermacdonald.valorgmcompanion.character.techniques.cores.Core;
import petermacdonald.valorgmcompanion.tools.ListTools;

/**
 * This class represents techniques. There is no reason to make a subclass of this class, so it is set final.
 */
public final class Technique {
    private String name;//The name of the technique
    private Core core;//The technique's core.
    private List<Mod> modifiers;//The modifiers attached to the technique
    private List<Limit> limits;//The limits attached to the technique
    private int level;//The technique's level, derived from the core level and modifiers. Cannot be set directly.
    private int staminaCost;//The technique's stamina cost, derived from the core's base stamina cost and its limits. Cannot be set directly.
    private String description;//The technique's description string. Generated by its core. Cannot be set directed.
    private final ValorCharacter character;//The character this technique is created for. Techniques cannot be transferred between characters; if you ever do want to move Techs, you need to make a copy.

    Technique(ValorCharacter character, Core core) {
        this.character = character;
        this.modifiers = new ArrayList<Mod>();
        this.limits = new ArrayList<Limit>();
        this.core = core;
        this.level = calculateLevel();
        this.staminaCost = calculateStaminaCost();
    }

    private int calculateLevel() {
        int temp = core.getLevel();
        for (Mod mod:modifiers) {
            temp += mod.getTotalCost(this);
        }
        return temp;
    }
    /*
        Returns the amount saved by the technique's limits.
    */
    private int calculateLimitSaved() {
        int temp = 0;
        for (Limit limit: limits) {
            temp+=limit.getTotalValue();
        }
        return temp;
    }

    /*
        Returns the net stamina cost
     */
    private int calculateStaminaCost() {
        return Math.max(0, core.calculateBaseStaminaCost(this)-calculateLimitSaved());
    }
    /*
        Gets the core to generate a description string, and sets it.
     */
    private void generateDescription() {
        description = core.generateDescription(this, character);
    }

    public void setAttribute(CoreAttribute attribute) {
        core.setAttribute(attribute);
        generateInfo();
    }

    public String getName() {
        return name;
    }

    public Core getCore() {
        return core;
    }

    public List<Mod> getModifiers() {
        return modifiers;
    }

    public List<Limit> getLimits() {
        return limits;
    }

    public int getLevel() {
        return level;
    }

    public int getStaminaCost() {
        return staminaCost;
    }

    public String getDescription() {
        return description;
    }

    public ValorCharacter getCharacter() {
        return character;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setCore(Core core) {
        this.core = core;
        clearIneligibleComponents();
        generateInfo();
    }

    /*
        returns true if the technique has a Special Modifier attached to it, and false otherwise.
     */
    public boolean isSpecial() {
        for (Mod mod:modifiers) {
            if (mod.isSpecial()) {
                return true;
            }
        }
        return false;
    }

    //This method returns the Line Attack modifier attached to this technique, if it exists. Otherwise, returns null.
    public Line getLineMod() {
        List<Mod> list =  getModifiers();
        for(Mod mod:list) {
            if (mod instanceof Line) {return (Line)mod;}
        }
        return null;
    }

    //This method returns the Ranged Technique modifier attached to this technique, if it exists. Otherwise, returns null.
    public Ranged getRangedMod() {
        List<Mod> list =  getModifiers();
        for(Mod mod:list) {
            if (mod instanceof Ranged) {return (Ranged)mod;}
        }
        return null;
    }

    public void addMod(Mod mod) {
        ListTools.addToList(mod, modifiers);
        generateInfo();
    }

    public void addLimit(Limit limit) {
        ListTools.addToList(limit, limits);
        generateInfo();
    }

    public void removeMod(Mod mod) {
        ListTools.removeFromList(mod, modifiers);
        generateInfo();
    }

    public void removeLimit(Limit limit) {
        ListTools.removeFromList(limit, limits);
        generateInfo();
    }


    /*
        Private function which causes the technique to generate the description, level, and stamina numbers.
         Called after we make changes that could affect those things.
     */
    private void generateInfo() {
        generateDescription();
        level = calculateLevel();
        staminaCost = calculateStaminaCost();
    }

    /*
        Private method which checks all mods and limits, and removes them if they can't be applied to the current core. Used to clean up the lists after a change of core type.
     */
    private void clearIneligibleComponents() {
        for (Mod mod:modifiers) {
            if (!mod.getEligibleCores().contains(core.getType())) {
                removeMod(mod);
            }
        }

        for (Limit limit:limits) {
            if (!limit.getEligibleCores().contains(core.getType())){
                removeLimit(limit);
            }
        }
    }
}
